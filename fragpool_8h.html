<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>fragpool: include/fragpool/fragpool.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">fragpool
   &#160;<span id="projectnumber">20170302</span>
   </div>
   <div id="projectbrief">Variable-sized packet memory management for embedded applications</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_d44c64559bbebec7f509842c48db8b23.html">include</a></li><li class="navelem"><a class="el" href="dir_d6eb3734645a836853efaf1d92921ba3.html">fragpool</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">fragpool.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Header providing interface for fragpool functions.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &lt;stdint.h&gt;</code><br />
</div>
<p><a href="fragpool_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfp__fragment__t.html">fp_fragment_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structFP__POOL__STRUCT__COMMON__.html">FP_POOL_STRUCT_COMMON_</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfp__pool__t.html">fp_pool_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a08ea0a54e22a10ba28949c35edd341ce"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fragpool_8h.html#a08ea0a54e22a10ba28949c35edd341ce">FP_VERSION</a>&#160;&#160;&#160;20170302</td></tr>
<tr class="separator:a08ea0a54e22a10ba28949c35edd341ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbc537581fe0c6aeb6b3f7346237f4c4"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fragpool_8h.html#afbc537581fe0c6aeb6b3f7346237f4c4">FP_MAX_FRAGMENT_SIZE</a>&#160;&#160;&#160;INT16_MAX</td></tr>
<tr class="separator:afbc537581fe0c6aeb6b3f7346237f4c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73c148db387f65467ac8b3abb5965f39"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fragpool_8h.html#a73c148db387f65467ac8b3abb5965f39">FP_EINVAL</a>&#160;&#160;&#160;1</td></tr>
<tr class="separator:a73c148db387f65467ac8b3abb5965f39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae56a55bb75cb7702f2867d2cff2d7df3"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fragpool_8h.html#ae56a55bb75cb7702f2867d2cff2d7df3">FP_POOL_STRUCT_COMMON</a></td></tr>
<tr class="separator:ae56a55bb75cb7702f2867d2cff2d7df3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a21432708f9e49a8b8528f075bd51ce4b"><td class="memItemLeft" align="right" valign="top">typedef uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fragpool_8h.html#a21432708f9e49a8b8528f075bd51ce4b">fp_size_t</a></td></tr>
<tr class="separator:a21432708f9e49a8b8528f075bd51ce4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7f18599bd466f1c09a5128431ce05b9"><td class="memItemLeft" align="right" valign="top">typedef int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fragpool_8h.html#af7f18599bd466f1c09a5128431ce05b9">fp_ssize_t</a></td></tr>
<tr class="separator:af7f18599bd466f1c09a5128431ce05b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7bd672f2250780f374c2f0cca02f144"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="structfp__fragment__t.html">fp_fragment_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fragpool_8h.html#aa7bd672f2250780f374c2f0cca02f144">fp_fragment_t</a></td></tr>
<tr class="separator:aa7bd672f2250780f374c2f0cca02f144"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84835fdc6168808fcd3319d2668eca16"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="structfp__pool__t.html">fp_pool_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fragpool_8h.html#a84835fdc6168808fcd3319d2668eca16">fp_pool_t</a></td></tr>
<tr class="separator:a84835fdc6168808fcd3319d2668eca16"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a36b73aec926b84742e2dbb01bd4866bc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fragpool_8h.html#a36b73aec926b84742e2dbb01bd4866bc">fp_reset</a> (<a class="el" href="structfp__pool__t.html">fp_pool_t</a> pool)</td></tr>
<tr class="separator:a36b73aec926b84742e2dbb01bd4866bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abaa7500c51a8a2743a14fdf0855405a1"><td class="memItemLeft" align="right" valign="top">uint8_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fragpool_8h.html#abaa7500c51a8a2743a14fdf0855405a1">fp_request</a> (<a class="el" href="structfp__pool__t.html">fp_pool_t</a> pool, <a class="el" href="fragpool_8h.html#a21432708f9e49a8b8528f075bd51ce4b">fp_size_t</a> min_size, <a class="el" href="fragpool_8h.html#a21432708f9e49a8b8528f075bd51ce4b">fp_size_t</a> max_size, uint8_t **fragment_endp)</td></tr>
<tr class="separator:abaa7500c51a8a2743a14fdf0855405a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad6744155cd0e00fb586f91b79628f6c"><td class="memItemLeft" align="right" valign="top">uint8_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fragpool_8h.html#aad6744155cd0e00fb586f91b79628f6c">fp_resize</a> (<a class="el" href="structfp__pool__t.html">fp_pool_t</a> pool, uint8_t *bp, <a class="el" href="fragpool_8h.html#a21432708f9e49a8b8528f075bd51ce4b">fp_size_t</a> new_size, uint8_t **fragment_endp)</td></tr>
<tr class="separator:aad6744155cd0e00fb586f91b79628f6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d4d9d64c34ba2dd50c24cb90446bc3e"><td class="memItemLeft" align="right" valign="top">uint8_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fragpool_8h.html#a6d4d9d64c34ba2dd50c24cb90446bc3e">fp_reallocate</a> (<a class="el" href="structfp__pool__t.html">fp_pool_t</a> pool, uint8_t *bp, <a class="el" href="fragpool_8h.html#a21432708f9e49a8b8528f075bd51ce4b">fp_size_t</a> min_size, <a class="el" href="fragpool_8h.html#a21432708f9e49a8b8528f075bd51ce4b">fp_size_t</a> max_size, uint8_t **fragment_endp)</td></tr>
<tr class="separator:a6d4d9d64c34ba2dd50c24cb90446bc3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12f8115544a2533a7c664d60877a2efe"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fragpool_8h.html#a12f8115544a2533a7c664d60877a2efe">fp_release</a> (<a class="el" href="structfp__pool__t.html">fp_pool_t</a> pool, const uint8_t *bp)</td></tr>
<tr class="separator:a12f8115544a2533a7c664d60877a2efe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3b9b2fe5781a2714ab320b90151e296"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fragpool_8h.html#ae3b9b2fe5781a2714ab320b90151e296">fp_validate</a> (const <a class="el" href="structfp__pool__t.html">fp_pool_t</a> pool)</td></tr>
<tr class="separator:ae3b9b2fe5781a2714ab320b90151e296"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Header providing interface for fragpool functions. </p>
<p>See <a class="el" href="index.html">Fragpool: Variable-sized packet memory management for embedded applications</a>.</p>
<dl class="section user"><dt>Homepage</dt><dd><a href="http://github.com/pabigot/fragpool">http://github.com/pabigot/fragpool</a> </dd></dl>
<dl class="section copyright"><dt>Copyright</dt><dd>Copyright 2012-2017, Peter A. Bigot. Licensed under <a href="http://www.opensource.org/licenses/BSD-3-Clause">BSD-3-Clause</a> </dd></dl>
</div><h2 class="groupheader">Macro Definition Documentation</h2>
<a id="a73c148db387f65467ac8b3abb5965f39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73c148db387f65467ac8b3abb5965f39">&sect;&nbsp;</a></span>FP_EINVAL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FP_EINVAL&#160;&#160;&#160;1</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The (positive) value of the error code returned when a fragpool function is invoked with unacceptable parameters. </p>

</div>
</div>
<a id="afbc537581fe0c6aeb6b3f7346237f4c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afbc537581fe0c6aeb6b3f7346237f4c4">&sect;&nbsp;</a></span>FP_MAX_FRAGMENT_SIZE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FP_MAX_FRAGMENT_SIZE&#160;&#160;&#160;INT16_MAX</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The maximum size of a fragment. This is intentionally a signed value. </p>

</div>
</div>
<a id="ae56a55bb75cb7702f2867d2cff2d7df3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae56a55bb75cb7702f2867d2cff2d7df3">&sect;&nbsp;</a></span>FP_POOL_STRUCT_COMMON</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FP_POOL_STRUCT_COMMON</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">uint8_t* pool_start;                          \</div><div class="line">  uint8_t* pool_end;                            \</div><div class="line">  uint8_t pool_alignment;                       \</div><div class="line">  uint8_t fragment_count</div></div><!-- fragment --><p>Prefix common to all pool structures.</p>
<p>For documentation on these fields see the pseudo-structure <a class="el" href="structFP__POOL__STRUCT__COMMON__.html">FP_POOL_STRUCT_COMMON_</a>.</p>
<p>Although struct <a class="el" href="structfp__pool__t.html">fp_pool_t</a> has a flexible array member that makes it easy to dynamically allocate a pool structure, the whole point of fragpool is its use in systems that don't do dynamic allocation. In that situation, each static pool definition needs its own structure that defines the fragment array to the correct size. An example of how to accomplish this while still using the generic type for reference to the pool is: </p><pre class="fragment">static uint8_t pool_data[POOL_SIZE];
static union {
  struct {
    FP_POOL_STRUCT_COMMON;
    struct fp_fragment_t fragment[POOL_FRAGMENTS];
  } fixed;
  struct fp_pool_t generic;
} pool_union = {
  .generic = {
    .pool_start = pool_data,
    .pool_end = pool_data + sizeof(pool_data),
    .pool_alignment = sizeof(int),
    .fragment_count = POOL_FRAGMENTS,
  }
};
fp_pool_t const pool = &amp;pool_union.generic;
</pre> 
</div>
</div>
<a id="a08ea0a54e22a10ba28949c35edd341ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08ea0a54e22a10ba28949c35edd341ce">&sect;&nbsp;</a></span>FP_VERSION</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FP_VERSION&#160;&#160;&#160;20170302</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A integral monotonically increasing version number </p>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="aa7bd672f2250780f374c2f0cca02f144"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7bd672f2250780f374c2f0cca02f144">&sect;&nbsp;</a></span>fp_fragment_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structfp__fragment__t.html">fp_fragment_t</a> * <a class="el" href="structfp__fragment__t.html">fp_fragment_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Bookkeeping for a fragment within the pool.</p>
<p>The fragment state is allocated if its memory has been made available to a caller; available if its memory has been returned to the pool; inactive if the pool partitions do not include this fragment.</p>
<dl class="section warning"><dt>Warning</dt><dd>The only reason you get to see the internals is because this is C and we need to statically allocate pools in user code. You don't get to inspect or mutate the fields of this structure, so any descriptive comments are irrelevant to you. </dd></dl>

</div>
</div>
<a id="a84835fdc6168808fcd3319d2668eca16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84835fdc6168808fcd3319d2668eca16">&sect;&nbsp;</a></span>fp_pool_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structfp__pool__t.html">fp_pool_t</a> * <a class="el" href="structfp__pool__t.html">fp_pool_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Bookkeeping for a fragment pool.</p>
<dl class="section warning"><dt>Warning</dt><dd>The only reason you get to see the internals is because this is C and we need to statically allocate pools in user code. You don't get to inspect or mutate the fields of this structure, so any descriptive comments are irrelevant to you. </dd></dl>

</div>
</div>
<a id="a21432708f9e49a8b8528f075bd51ce4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21432708f9e49a8b8528f075bd51ce4b">&sect;&nbsp;</a></span>fp_size_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef uint16_t <a class="el" href="fragpool_8h.html#a21432708f9e49a8b8528f075bd51ce4b">fp_size_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Type used to represent a fragment size in API calls.</p>
<dl class="section note"><dt>Note</dt><dd>Due to sign tricks used internally, the effective maximum size is <a class="el" href="fragpool_8h.html#af7f18599bd466f1c09a5128431ce05b9">fp_ssize_t</a>. </dd></dl>

</div>
</div>
<a id="af7f18599bd466f1c09a5128431ce05b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7f18599bd466f1c09a5128431ce05b9">&sect;&nbsp;</a></span>fp_ssize_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int16_t <a class="el" href="fragpool_8h.html#af7f18599bd466f1c09a5128431ce05b9">fp_ssize_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A signed fragment size, for internal use where the sign carries non-length significance. </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a6d4d9d64c34ba2dd50c24cb90446bc3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d4d9d64c34ba2dd50c24cb90446bc3e">&sect;&nbsp;</a></span>fp_reallocate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t* fp_reallocate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structfp__pool__t.html">fp_pool_t</a>&#160;</td>
          <td class="paramname"><em>pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>bp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="fragpool_8h.html#a21432708f9e49a8b8528f075bd51ce4b">fp_size_t</a>&#160;</td>
          <td class="paramname"><em>min_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="fragpool_8h.html#a21432708f9e49a8b8528f075bd51ce4b">fp_size_t</a>&#160;</td>
          <td class="paramname"><em>max_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t **&#160;</td>
          <td class="paramname"><em>fragment_endp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Attempt to resize a fragment allowing moves.</p>
<p>This operation will place the fragment in the best available location, moving it if necessary to do so. The expectation is this operation is equivalent to saving the current fragment contents, releasing the fragment, requesting a new fragment with the specified characteristics, and initializing it with the old fragment contents, but without requiring external storage for what's currently in the fragment.</p>
<p>If no satisfactory fragment can be found, the function returns a null pointer, but the existing fragment is not affected.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pool</td><td>the pool from which <code>bp</code> was allocated</td></tr>
    <tr><td class="paramname">bp</td><td>the start of an allocated block returned by <a class="el" href="fragpool_8h.html#abaa7500c51a8a2743a14fdf0855405a1">fp_request()</a>, <a class="el" href="fragpool_8h.html#aad6744155cd0e00fb586f91b79628f6c">fp_resize()</a>, or <a class="el" href="fragpool_8h.html#a6d4d9d64c34ba2dd50c24cb90446bc3e">fp_reallocate()</a>.</td></tr>
    <tr><td class="paramname">min_size</td><td>the minimum acceptable size for a new fragment. Up to this many octets from the existing fragment are copied if the new fragment begins at a different location. The current fragment may be smaller or larger than this size. For the purposes of determining a new location the value is increased to satisfy the pool alignment, but the provided value is used when preserving the buffer contents.</td></tr>
    <tr><td class="paramname">max_size</td><td>the maximum size desired for the fragment, in bytes. This is increased if necessary to satisfy the pool alignment requirements. Use <a class="el" href="fragpool_8h.html#afbc537581fe0c6aeb6b3f7346237f4c4">FP_MAX_FRAGMENT_SIZE</a> to get the largest available fragment.</td></tr>
    <tr><td class="paramname">fragment_endp</td><td>where to store the end of the fragment. The stored value is unchanged if the call returns <code>NULL</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the start of the returned region, or a null pointer if the allocation cannot be satisfied. </dd></dl>

</div>
</div>
<a id="a12f8115544a2533a7c664d60877a2efe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12f8115544a2533a7c664d60877a2efe">&sect;&nbsp;</a></span>fp_release()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int fp_release </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structfp__pool__t.html">fp_pool_t</a>&#160;</td>
          <td class="paramname"><em>pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>bp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Release a block of memory to the pool.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pool</td><td>the pool from which bp was allocated</td></tr>
    <tr><td class="paramname">bp</td><td>the start of an allocated block returned by <a class="el" href="fragpool_8h.html#abaa7500c51a8a2743a14fdf0855405a1">fp_request()</a>, <a class="el" href="fragpool_8h.html#aad6744155cd0e00fb586f91b79628f6c">fp_resize()</a>, or <a class="el" href="fragpool_8h.html#a6d4d9d64c34ba2dd50c24cb90446bc3e">fp_reallocate()</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>zero if the block is released, or an error code if <code>bp</code> is invalid. </dd></dl>

</div>
</div>
<a id="abaa7500c51a8a2743a14fdf0855405a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abaa7500c51a8a2743a14fdf0855405a1">&sect;&nbsp;</a></span>fp_request()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t* fp_request </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structfp__pool__t.html">fp_pool_t</a>&#160;</td>
          <td class="paramname"><em>pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="fragpool_8h.html#a21432708f9e49a8b8528f075bd51ce4b">fp_size_t</a>&#160;</td>
          <td class="paramname"><em>min_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="fragpool_8h.html#a21432708f9e49a8b8528f075bd51ce4b">fp_size_t</a>&#160;</td>
          <td class="paramname"><em>max_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t **&#160;</td>
          <td class="paramname"><em>fragment_endp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Obtain a block of memory from the pool.</p>
<p>A block of memory of at least <code>min_size</code> octets is allocated from the pool and returned to the caller. The value pointed to by <code>fragment_endp</code> is updated to reflect the first byte past the end of the allocated region. The "best" available fragment is selected taking into account the required <code>min_size</code> and the desired <code>max_size</code>. If the requested maximum size is smaller than the selected fragment and there are slots available, the remainder is split off as a new available fragment.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pool</td><td>the pool from which memory is obtained</td></tr>
    <tr><td class="paramname">min_size</td><td>the minimum size acceptable fragment, in bytes. This is increased if necessary to satisfy the pool alignment requirements.</td></tr>
    <tr><td class="paramname">max_size</td><td>the maximum size desired for the fragment, in bytes. This is increased if necessary to satisfy the pool alignment requirements. Use <a class="el" href="fragpool_8h.html#afbc537581fe0c6aeb6b3f7346237f4c4">FP_MAX_FRAGMENT_SIZE</a> to get the largest available fragment.</td></tr>
    <tr><td class="paramname">fragment_endp</td><td>where to store the end of the fragment</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the start of the returned region, or a null pointer if the allocation cannot be satisfied. </dd></dl>

</div>
</div>
<a id="a36b73aec926b84742e2dbb01bd4866bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36b73aec926b84742e2dbb01bd4866bc">&sect;&nbsp;</a></span>fp_reset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fp_reset </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structfp__pool__t.html">fp_pool_t</a>&#160;</td>
          <td class="paramname"><em>pool</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reset the pool.</p>
<p>All memory is assigned to a single fragment which is marked unallocated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pool</td><td>the pool to be validated </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aad6744155cd0e00fb586f91b79628f6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad6744155cd0e00fb586f91b79628f6c">&sect;&nbsp;</a></span>fp_resize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t* fp_resize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structfp__pool__t.html">fp_pool_t</a>&#160;</td>
          <td class="paramname"><em>pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>bp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="fragpool_8h.html#a21432708f9e49a8b8528f075bd51ce4b">fp_size_t</a>&#160;</td>
          <td class="paramname"><em>new_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t **&#160;</td>
          <td class="paramname"><em>fragment_endp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Attempt to resize a fragment in-place.</p>
<p>This operation will release trailing bytes to the pool or attempt to extend the fragment if the following fragment is available.</p>
<p>If the new size is smaller, the excess will be returned to the pool if possible.</p>
<p>If the new size is larger and the following fragment is available, the fragment will be extended to be no longer than new_size. It may be extended even if the requested new size cannot be satisfied.</p>
<p>The resize will not move any data. The caller is responsible for checking <code>*fragment_endp</code> to determine the effect of the resize.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pool</td><td>the pool from which <code>bp</code> was allocated</td></tr>
    <tr><td class="paramname">bp</td><td>the start of an allocated block returned by <a class="el" href="fragpool_8h.html#abaa7500c51a8a2743a14fdf0855405a1">fp_request()</a>, <a class="el" href="fragpool_8h.html#aad6744155cd0e00fb586f91b79628f6c">fp_resize()</a>, or <a class="el" href="fragpool_8h.html#a6d4d9d64c34ba2dd50c24cb90446bc3e">fp_reallocate()</a>.</td></tr>
    <tr><td class="paramname">new_size</td><td>the new desired size for the fragment, in bytes. This is increased if necessary to satisfy the pool alignment requirements. Use <a class="el" href="fragpool_8h.html#afbc537581fe0c6aeb6b3f7346237f4c4">FP_MAX_FRAGMENT_SIZE</a> to get the largest available fragment.</td></tr>
    <tr><td class="paramname">fragment_endp</td><td>where to store the end of the fragment. This must not be <code>NULL</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>bp</code> if the resize succeeded, or a null pointer if an invalid fragment or pool address was provided. In either case, the <code>new_size</code> octets beginning at <code>bp</code> are unchanged. <code>*fragment_endp</code> is updated to reflect the actual end of the fragment after the resize completes.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Expect <code>new_size &lt;= (*fragment_endp - bp)</code> to hold on successful completion. Equality should not be expected. </dd></dl>

</div>
</div>
<a id="ae3b9b2fe5781a2714ab320b90151e296"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3b9b2fe5781a2714ab320b90151e296">&sect;&nbsp;</a></span>fp_validate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int fp_validate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structfp__pool__t.html">fp_pool_t</a>&#160;</td>
          <td class="paramname"><em>pool</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Verify the integrity of the pool.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pool</td><td>the pool to be validated</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>zero if the pool is valid, or an internal error code if an integrity test fails. </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
